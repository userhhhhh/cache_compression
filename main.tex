\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{ctex} 

\title{Cache Compression}
\author{qishuo hua}
\date{2024.12}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{频繁值压缩（Frequent Value Compression）}

\subsection{背景}
芯片多处理器（CMP）的普及导致了大型片上高速缓存的集成。出于可扩展性的原因，大型片上缓存通常被划分为较小的 bank，这些 bank 通过基于数据包的片上网络（NoC）互连。随着单个芯片上集成的内核和高速缓存库数量的增加，片上网络会带来显著的通信延迟和功耗。频繁值压缩可以优化 NoC 的功率和性能。在读到的论文中的数据显示，这个方案使路由器功率降低了 16.7\%，CPI 降低了 23.5\%。与零模式压缩方案相比，频繁值方案可节省高达 11.0\% 的路由器功率，并将 CPI 降低多达 14.5\%。

\subsection{频繁值压缩的基本思想}

\begin{itemize}
  \item 通过识别数据中频繁出现的值，将这些值替换成更小的标识符（如整数编号或指针），以减少存储所需的空间。
  \item 对于不常见或不频繁出现的值，通常保留原始数据或使用某种较为高效的压缩策略。
\end{itemize}

\subsection{频繁值压缩的常见实现方式}

\subsubsection{基于频率排序的映射（频繁值替换）}
首先统计数据中各个值的出现频率，然后将频繁出现的值替换为一个小的编号或更紧凑的表示。较不常见的值则保留原样或使用更高效的压缩算法。

\textbf{优点：}
\begin{itemize}
  \item 对频繁值进行压缩，节省空间。
  \item 通过编号替换，降低存储负担。
\end{itemize}

\textbf{缺点：}
\begin{itemize}
  \item 对不频繁值的压缩效果较差，可能会占用更多存储空间。
\end{itemize}

\subsubsection{哈夫曼编码（Huffman Encoding）}
根据各个值的出现频率分配变长编码。频繁出现的值被分配较短的编码，较少出现的值分配较长的编码。

\textbf{优点：}
\begin{itemize}
  \item 对频繁出现的值进行高效压缩，减少存储空间。
  \item 编码和解码过程通常较为高效。
\end{itemize}

\textbf{缺点：}
\begin{itemize}
  \item 对于小数据集或者非常不均匀的数据分布，哈夫曼编码的效果可能较差。
\end{itemize}

\subsubsection{字典压缩（Dictionary Compression）}
通过建立词典，将数据中的重复模式替换为短的标识符。在频繁值压缩中，字典压缩通过将常见的值或模式映射到较小的标识符来实现压缩。

\textbf{优点：}
\begin{itemize}
  \item 对重复模式和频繁值进行有效压缩，节省空间。
  \item 支持动态和静态字典，适用于不同类型的数据。
\end{itemize}

\textbf{缺点：}
\begin{itemize}
  \item 如果频繁值变化较快，字典更新会带来额外的开销。
  \item 存储字典本身也需要一定的空间。
\end{itemize}

\subsubsection{Delta 编码}
Delta 编码是一种通过记录值之间的差异（增量）来压缩数据的方法。如果数据中的频繁值变化较小，Delta 编码可以通过存储连续值的差异而不是原始值来减少存储空间。

\textbf{优点：}
\begin{itemize}
  \item 对于具有较小变化的频繁值特别有效，压缩率高。
  \item 适用于时间序列数据和差异较小的数值型数据。
\end{itemize}

\textbf{缺点：}
\begin{itemize}
  \item 如果数据变化较大，Delta 编码的效果不好。
  \item 需要额外的逻辑来处理边界值和解码。
\end{itemize}

\subsection{关键步骤}
\begin{itemize}
  \item \textbf{统计频率：} 分析数据集中的每个元素出现的频率。
  \item \textbf{识别频繁值：} 根据频率阈值来决定哪些值是频繁值。频繁值是那些出现次数大于某个预设阈值的元素。
  \item \textbf{替换频繁值：} 将频繁值替换为短标识符或编码。
  \item \textbf{存储字典：} 将频繁值与其替代符号（如ID、编码）映射存储到字典中。
  \item \textbf{处理非频繁值：} 对于出现次数较少的元素，可以采用原始存储，或使用其他压缩算法。
\end{itemize}

\subsection{一些介绍}

频繁值压缩（Frequent Value Compression）通过识别和压缩那些在数据集中出现频率较高的值来减少存储空间占用，提升数据访问和处理效率。这种技术通常用于数据传输、数据库存储、日志文件处理等场景，尤其在处理大量重复数据时非常有效。

一旦为应用程序确定了频繁值及其各自的码字，就需要将它们合并到集成到存储器体系结构中的压缩引擎中。为了实现这一点，我们使用一组 CAM 来存储频繁值和它们各自的码字。为了便于实现这一点，我们使用 N 个最常见的值构造 Huffman 编码树，其中 N 是 CAM 的大小。压缩只需使用一个简单的 CAM 将输入的写入数据与保存的频繁值进行匹配，并用它们的码字替换匹配值。解压也同样简单，使用 TCAM 进行相同的过程，代码字中未使用的位设置为不关心值。TCAM 非常适合这种应用，因为 Huffman 代码是前缀自由的，这意味着没有任何码字是任何其他码字的前缀。

频繁值压缩是有益的，因为它在硬件中实现简单，压缩和解压缩速度快。一个 CAM 查找操作的电路级模拟显示，在高达 128 个值的 CAM 大小上，访问延迟仅为一个周期。此外，使用 Huffman 编码作为我们的编码技术应该会进一步减少位写入，代价是在执行之前需要在应用程序上执行 profiling。

\subsection{压缩效果与优化}

\textbf{压缩比：} 频繁值压缩通常可以大幅提高存储效率，尤其是在数据集中频繁值占有较大比例时。

\textbf{性能优化：} 在实际应用中，可以结合多种压缩技术进行优化。例如，使用频繁值压缩和哈夫曼编码组合，针对不同数据特性选择最佳压缩策略。

\subsection{不足}
\begin{itemize}
  \item \textbf{频率统计开销：} 计算频率和构建映射可能会增加一定的计算和内存开销，尤其在数据量非常大的时候。
  \item \textbf{动态变化的数据集：} 如果数据集中的值频繁变化，动态更新频繁值的映射或字典可能会比较复杂，可能影响压缩效果。
  \item \textbf{解码性能：} 对于解码过程，需要额外的存储（如字典或哈夫曼树），如果存储和解码过程不够优化，可能会影响性能。
\end{itemize}

\subsection{总结}
频繁值压缩是一种通过识别和压缩频繁出现的值来减少存储空间和提高处理效率的技术。其实现可以通过频率映射、哈夫曼编码、字典压缩和 Delta 编码等方法。


\section{频繁模式压缩（Frequent Pattern Compression）}

\textbf{Frequent Pattern Compression (FPC)} 是一种数据压缩技术，旨在通过识别和利用数据中频繁出现的模式来实现高效的压缩。

\subsection{FPC的基本思想}

FPC 是基于频繁模式（Frequent Patterns）的，频繁模式是指在数据集中频繁出现的项或项集。FPC 的目标是通过找到这些频繁出现的模式，然后利用它们来有效地压缩数据。

\textbf{关键步骤：}
\begin{itemize}
  \item \textbf{频繁模式发现}：首先需要从原始数据中发现频繁的模式或项集。常见的算法包括 Apriori、FP-growth 等。
  \item \textbf{模式压缩}：一旦识别出频繁模式，就将这些模式替换成更紧凑的表示形式。例如，使用一个小的符号或数字代替长的字符串。
  \item \textbf{编码和压缩}：通过使用这些频繁的模式作为编码符号，将原始数据进行压缩。频繁模式可以通过哈夫曼编码、算术编码或其他方法进一步压缩。
\end{itemize}

\subsection{FPC的核心特点}

\begin{itemize}
  \item 此方案中，频繁模式压缩（FPC）通过以压缩格式存储常见的字模式并附带适当的前缀，逐字压缩单个缓存线。
  \item 对于64字节缓存线，假设每个周期12 FO4门延迟，压缩可在三个周期内完成，解压缩可在五个周期内完成。
  \item 我们提出一种压缩缓存设计，其中数据以压缩形式存储在二级缓存中，但在一级缓存中不压缩。二级缓存线被压缩到预定的大小，永远不会超过其原始大小，以减少反编译开销。
  \item 这个简单的方案提供了与具有更高缓存命中延迟的更复杂方案相当的压缩比。
\end{itemize}

\subsection{FPC压缩方案}

\subsubsection{压缩前缀编码特点}
缓存线 = Cache line，频繁模式压缩（FPC）基于缓存线压缩/解压缩。每个高速缓存线被划分为32位字（例如，64字节线为16个字）。每个32位的字被编码为3位pre-fix（前缀）加上数据。

\subsubsection{压缩层次特点}
我们提出了一种压缩缓存设计，其中数据未压缩存储在一级缓存中，压缩存储在二级缓存中。
\begin{itemize}
  \item \textbf{优点}：有助于减少许多阻碍性能的代价高昂的二级缓存未命中，同时又不会影响一级命中的常见情况。
  \item \textbf{缺点}：增加了在两个级别之间移动时压缩或解压缩缓存线的开销。
\end{itemize}

\subsubsection{压缩}
\begin{itemize}
  \item 当数据从一级缓存写入二级缓存时，会发生缓存线压缩。使用一个简单的电路（并行地）检查每个字的模式匹配，可以很容易地压缩缓存线。如果一个字与七种可压缩模式中的任何一种匹配，则使用一个简单的编码器电路将该字编码为其最紧凑的形式。如果未找到匹配项，则整个字将与pre fix“111”一起存储。
  \item 对于zero-run模式，我们需要检测连续的0的个数，并增加数据值来表示它们的计数。由于在我们的设计中，零运行被限制为8个零（多了的前缀就不是000了），因此可以使用简单的多路复用/加法器电路在一个周期内实现。
  \item 缓存线压缩可以在内存管道中实现，方法是在L1到L2写入路径上分配三个管道阶段（一个用于模式匹配，一个用于零运行编码，一个用于收集压缩线）。一个包含压缩和未压缩形式的几个条目的小型缓存可用于隐藏一级写回的压缩延迟。
\end{itemize}

\subsubsection{解压缩}
\begin{itemize}
  \item 当数据从二级缓存读取到一级缓存时，会发生缓存线解压缩。对于工作集不在一级缓存中的大多数基准测试来说，这是一个经常发生的事件。
  \item 解压缩延迟非常关键，因为它直接添加到二级命中延迟中。
  \item 解压是一个比压缩慢的过程，因为行中所有单词的前缀都必须串联访问，因为每个pre-fix用于确定其对应的编码单词的长度，从而确定所有后续压缩单词的起始位置。
  \item 举个例子，现在L2CACHE里面装的数据是001010001000011111：

  第一条：读001，前缀，则后面4bit是数据位，所以L1CACHE中的数据是：
  \[
  0000, 0000, 0000, 0000
  \]
  第二条：继续读010，前缀，则后面8位是数据位，所以L1CACHE中的数据是：
  \[
  0000, 0000, 0001, 1111
  \]
\end{itemize}

\subsection{FPC的挑战}

\begin{itemize}
  \item \textbf{大数据集的处理}：随着数据集的增大，频繁模式的发现和压缩变得更加困难。
  \item \textbf{在线和增量压缩}：对于流数据，需要开发更高效的增量式算法，以便实时更新频繁模式并执行压缩。
  \item \textbf{多模态数据的压缩}：如何同时压缩多种类型的数据（如文本、图像和视频等）中的频繁模式，是一个重要的研究方向。
\end{itemize}

\subsection{总结}
Frequent Pattern Compression (FPC) 能够有效减少数据的存储和传输需求，适用于有大量重复模式的数据集，但其计算开销可能较高。


\section{BDI压缩（Base-Delta-Immediate Compression）}

\subsection{BDI的基本思想}

\begin{itemize}
    \item 关键思想是，对于许多缓存线，缓存线中的值具有较低的动态范围，即缓存线中存储的值之间的差异很小。因此，可以使用一个基值和一个差异数组来表示缓存线，这些差异数组的组合大小远小于原始缓存线（我们称之为基+增量编码）。
    \item 对于我们研究的工作负载，最好的选择是有两个基，其中一个基总是零。使用这两个基值（零和其他值），我们的方案可以有效地压缩包含两个分离率动态范围的混合缓存线：一个以从缓存线的实际内容中选择的任意值（例如指针值）为中心，另一个接近于零（例如小整数值）。
    \item 以往的方法都是在一个缓存线里面进行压缩的工作，粒度是单个字是否压缩，而BDI只有两种情况：1. 整个缓存线都压缩。2. 整个缓存线都不压缩。
\end{itemize}

\subsection{BDI压缩方案}

\subsubsection{一些约定}

\begin{itemize}
    \item 每个缓存线是 C 字节，每个被压缩的集合都是 k 字节。
    \item 对于 64B 的缓存线而言，有 88B，164B，32$\times$2B 三种规格。
    \item 目标是确定 B*(BASE值)和 k 的值，$\{k,B^*,\delta = (\delta_1,\delta_2,\dots)\}$。
    \item 要使缓存线可压缩，表示差异所需的字节数必须严格小于表示其自身值所需的字节数。
    \item B 值的确定和缓存线的关系：B 的最佳值应介于 min(S) 和 max(S) 之间。事实上，只有在最小值、最大值或介于两者之间时才能达到最佳值。
\end{itemize}

\subsubsection{参数的确定}

\begin{itemize}
    \item \textbf{确定 k 的值}: 为所有缓存线选择一个 k 值将显著减少压缩的机会。举个例子，考虑两条缓存线，一条表示指向某个内存区域的 4 字节指针表（类似于图 4），另一条表示存储为 2 字节整数的窄值数组。对于第一个缓存线，k 的可能最佳值是 4，因为将缓存线划分为一组具有不同 k 的值可能会导致动态范围的增加并降低压缩的可能性。类似地，对于第二个缓存线，k 的最佳值可能是 2。
    
    因此，为了通过迎合多种模式来增加压缩的机会，我们的压缩算法尝试同时使用三个不同的 k 值：2、4 和 8 来压缩缓存线。然后使用提供最大压缩率或根本不压缩的值压缩缓存线。
    
    \item \textbf{确定 B*}: 对于 $k \in \{2, 4, 8\}$ 的每个可能值，缓存线被分割成大小为 k 的值，并且对于基的最佳值 B 可以使用观察 2 来确定。然而，以这种方式计算 B* 需要计算值集的最大值或最小值，这增加了逻辑复杂性并显著增加了压缩的延迟。
    
    为了避免压缩延迟增加和降低硬件复杂性，我们决定使用值集的第一个值作为 B 的近似值。
\end{itemize}

\subsubsection{解压过程}

$v_i$ 简单地由 $v_i = B^* + \Delta_i$ 给出。因此，可以使用 SIMD 式矢量加法器并行计算缓存线中的值。因此，使用一组简单的加法器，可以在进行整数向量加法所需的时间内对整个缓存线进行解压缩。

\subsubsection{使用多个基的原因}

很明显，并不是每个缓存线都可以用这种形式表示，因此，一些基准没有高压缩比，例如 MCF。发生这种情况的一个常见原因是，其中一些应用程序可以在同一缓存线中混合不同类型的数据，例如指针和 1 字节整数的结构。

经过实验，发现两个基压缩是最好的。不幸的是，有两个基的 B+ 有一个严重的缺点：必须找到第二个基。搜索第二个任意基值（甚至是次优值）可以为压缩硬件增加重要的复杂度。这就引出了如何有效地找到两个基本值的问题。

\subsection{BDI压缩的挑战}

\begin{itemize}
    \item \textbf{基准值的选择}: 基准值的选择可能影响压缩效果。如果基准值选择不当，增量值可能会变得较大，从而降低压缩率。
    \item \textbf{计算开销}: 对于某些数据，尤其是非连续变化的数据，BDI压缩可能并不适用，增量计算可能带来额外的计算开销。
    \item \textbf{数据不连续性}: BDI压缩的效果最佳于连续数据，对于差异较大的数据，增量的编码效率较低，可能导致压缩率不理想。
\end{itemize}

\subsection{总结}

BDI压缩适用于连续数据和相似数据的压缩。通过使用基准值和增量值，BDI压缩可以显著减少数据的存储需求，且在硬件实现中非常高效。


\end{document}



